{"data":{"edges":[],"nodes":[{"data":{"node":{"template":{"_type":"Component","code":{"type":"code","required":true,"placeholder":"","list":false,"show":true,"multiline":true,"value":"\"\"\"\nEnhanced Exoplanet Classification Component for Langflow\n========================================================\n\nProvides rich, detailed scientific analysis with multiple output types.\n\"\"\"\n\nfrom langflow.custom import Component\nfrom langflow.io import FloatInput, Output, MessageTextInput\nfrom langflow.schema import Data, Message\nimport joblib\nimport pandas as pd\nimport numpy as np\nimport os\n\n\nclass ExoplanetClassifier(Component):\n    display_name = \"Exoplanet Classifier\"\n    description = \"Classify stellar observations with detailed scientific analysis\"\n    documentation: str = \"https://docs.langflow.org/components-custom-components\"\n    icon = \"ðŸŒŸ\"\n    name = \"ExoplanetClassifier\"\n    \n    inputs = [\n        FloatInput(name=\"koi_period\", display_name=\"Orbital Period (days)\", value=9.5, required=True),\n        FloatInput(name=\"koi_depth\", display_name=\"Transit Depth (ppm)\", value=850.0, required=True),\n        FloatInput(name=\"koi_duration\", display_name=\"Transit Duration (hours)\", value=2.8, required=True),\n        FloatInput(name=\"koi_prad\", display_name=\"Planetary Radius (Earth radii)\", value=2.2, required=True),\n        FloatInput(name=\"koi_teq\", display_name=\"Temperature (K)\", value=1150.0, required=False),\n        FloatInput(name=\"koi_insol\", display_name=\"Stellar Flux\", value=180.0, required=False),\n        FloatInput(name=\"koi_impact\", display_name=\"Impact Parameter\", value=0.35, required=False),\n        FloatInput(name=\"koi_steff\", display_name=\"Stellar Temperature (K)\", value=5780.0, required=False),\n        FloatInput(name=\"koi_srad\", display_name=\"Stellar Radius\", value=0.93, required=False),\n        FloatInput(name=\"koi_slogg\", display_name=\"Stellar Gravity\", value=4.45, required=False),\n        MessageTextInput(\n            name=\"model_path\",\n            display_name=\"Model File Path\",\n            value=\"/app/data/.cache/langflow/b7c77ed2-b35a-4605-8b54-9a2787792e35/exoplanet_model.pkl\",\n            advanced=True,\n        ),\n    ]\n    \n    outputs = [\n        Output(display_name=\"Classification\", name=\"classification\", method=\"classify_observation\"),\n        Output(display_name=\"Detailed Analysis\", name=\"analysis\", method=\"classify_observation\"),\n        Output(display_name=\"Summary Message\", name=\"summary\", method=\"classify_observation\"),\n        Output(display_name=\"Recommendations\", name=\"recommendations\", method=\"classify_observation\"),\n    ]\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._pipeline = None\n    \n    def load_model(self):\n        \"\"\"Load the trained model.\"\"\"\n        if self._pipeline is not None:\n            return\n        \n        model_path = self.model_path\n        if not os.path.exists(model_path):\n            raise FileNotFoundError(f\"Model not found: {model_path}\")\n        \n        self._pipeline = joblib.load(model_path)\n        \n        if not isinstance(self._pipeline, dict):\n            raise ValueError(\"Invalid model file! Need complete exoplanet_model.pkl\")\n        \n        self.status = \"Model loaded\"\n    \n    def classify_observation(self) -> tuple[Data, Data, Message, Message]:\n        \"\"\"Classify with comprehensive analysis.\"\"\"\n        \n        try:\n            self.load_model()\n            \n            # Gather observation\n            observation = {\n                'koi_period': self.koi_period,\n                'koi_depth': self.koi_depth,\n                'koi_duration': self.koi_duration,\n                'koi_prad': self.koi_prad,\n                'koi_teq': self.koi_teq if self.koi_teq is not None else np.nan,\n                'koi_insol': self.koi_insol if self.koi_insol is not None else np.nan,\n                'koi_impact': self.koi_impact if self.koi_impact is not None else np.nan,\n                'koi_steff': self.koi_steff if self.koi_steff is not None else np.nan,\n                'koi_srad': self.koi_srad if self.koi_srad is not None else np.nan,\n                'koi_slogg': self.koi_slogg if self.koi_slogg is not None else np.nan,\n            }\n            \n            # Make prediction\n            prediction_result = self._predict(observation)\n            \n            # Generate comprehensive analysis\n            planet_type = self._classify_planet_type(observation)\n            habitability = self._assess_habitability(observation)\n            detection_quality = self._assess_detection_quality(observation)\n            comparisons = self._compare_to_known_planets(observation)\n            feature_analysis = self._detailed_feature_analysis(observation, prediction_result)\n            \n            # Build classification output\n            classification = Data(data={\n                \"prediction\": prediction_result['prediction'],\n                \"confidence\": prediction_result['confidence'],\n                \"probability_exoplanet\": prediction_result['probability_exoplanet'],\n                \"probability_false_positive\": prediction_result['probability_false_positive'],\n                \"planet_type\": planet_type,\n                \"is_potentially_habitable\": habitability['is_habitable'],\n                \"detection_confidence\": detection_quality['overall_quality']\n            })\n            \n            # Build detailed analysis output\n            analysis = Data(data={\n                \"classification\": {\n                    \"prediction\": prediction_result['prediction'],\n                    \"confidence\": prediction_result['confidence'],\n                    \"probabilities\": {\n                        \"exoplanet\": prediction_result['probability_exoplanet'],\n                        \"false_positive\": prediction_result['probability_false_positive']\n                    }\n                },\n                \"physical_characteristics\": {\n                    \"planet_type\": planet_type['category'],\n                    \"planet_class\": planet_type['class'],\n                    \"radius_earth\": observation['koi_prad'],\n                    \"radius_jupiter\": observation['koi_prad'] / 11.2,\n                    \"mass_estimate_earth\": planet_type['mass_estimate'],\n                    \"temperature_k\": observation['koi_teq'],\n                    \"temperature_c\": observation['koi_teq'] - 273.15 if not np.isnan(observation['koi_teq']) else None,\n                    \"size_comparison\": planet_type['size_comparison']\n                },\n                \"orbital_characteristics\": {\n                    \"period_days\": observation['koi_period'],\n                    \"period_years\": observation['koi_period'] / 365.25,\n                    \"semi_major_axis_au\": self._estimate_semi_major_axis(observation),\n                    \"stellar_flux\": observation['koi_insol'],\n                    \"habitable_zone_position\": habitability['hz_position'],\n                    \"orbital_distance_description\": self._describe_orbital_distance(observation)\n                },\n                \"habitability_assessment\": {\n                    \"is_potentially_habitable\": habitability['is_habitable'],\n                    \"habitability_score\": habitability['score'],\n                    \"favorable_factors\": habitability['favorable'],\n                    \"unfavorable_factors\": habitability['unfavorable'],\n                    \"habitable_zone_status\": habitability['hz_status'],\n                    \"temperature_suitability\": habitability['temp_suitability']\n                },\n                \"detection_quality\": {\n                    \"overall_quality\": detection_quality['overall_quality'],\n                    \"signal_strength\": detection_quality['signal_strength'],\n                    \"transit_depth_quality\": detection_quality['depth_quality'],\n                    \"geometric_probability\": detection_quality['geometric_prob'],\n                    \"detection_difficulty\": detection_quality['difficulty']\n                },\n                \"stellar_system\": {\n                    \"star_type\": self._classify_star(observation),\n                    \"stellar_temperature_k\": observation['koi_steff'],\n                    \"stellar_radius_solar\": observation['koi_srad'],\n                    \"stellar_mass_estimate\": self._estimate_stellar_mass(observation),\n                    \"system_age_estimate\": \"Unknown (requires additional data)\"\n                },\n                \"feature_importance\": {\n                    \"top_features\": prediction_result['top_features'],\n                    \"feature_contributions\": feature_analysis['contributions'],\n                    \"unusual_values\": feature_analysis['unusual_values']\n                },\n                \"comparisons_to_known_exoplanets\": comparisons,\n                \"scientific_context\": {\n                    \"discovery_method\": \"Transit photometry\",\n                    \"telescope\": \"Kepler Space Telescope\",\n                    \"typical_detection_rate\": \"~1 in 100 Kepler candidates are confirmed exoplanets\",\n                    \"false_positive_causes\": [\n                        \"Eclipsing binary stars\",\n                        \"Background contaminating stars\",\n                        \"Stellar activity and noise\",\n                        \"Instrumental artifacts\"\n                    ]\n                },\n                \"raw_input\": observation\n            })\n            \n            # Build summary message\n            summary_text = self._create_summary(\n                observation, prediction_result, planet_type, \n                habitability, detection_quality\n            )\n            summary = Message(text=summary_text)\n            \n            # Build recommendations\n            recommendations_text = self._create_recommendations(\n                prediction_result, planet_type, habitability, detection_quality\n            )\n            recommendations = Message(text=recommendations_text)\n            \n            # Update status\n            self.status = f\"{prediction_result['prediction']} ({prediction_result['confidence']:.1%})\"\n            \n            return classification, analysis, summary, recommendations\n            \n        except Exception as e:\n            error_msg = f\"Error: {str(e)}\"\n            error_data = Data(data={\"error\": error_msg})\n            error_message = Message(text=error_msg)\n            return error_data, error_data, error_message, error_message\n    \n    def _predict(self, obs: dict) -> dict:\n        \"\"\"Core ML prediction.\"\"\"\n        df = pd.DataFrame([obs])[self._pipeline['feature_names']]\n        df_proc = self._pipeline['scaler'].transform(self._pipeline['imputer'].transform(df))\n        \n        pred = self._pipeline['model'].predict(df_proc)[0]\n        proba = self._pipeline['model'].predict_proba(df_proc)[0]\n        \n        importances = self._pipeline['model'].feature_importances_\n        top_features = sorted(\n            zip(self._pipeline['feature_names'], importances),\n            key=lambda x: x[1], reverse=True\n        )\n        \n        return {\n            'prediction': 'CONFIRMED' if pred == 1 else 'FALSE POSITIVE',\n            'confidence': float(max(proba)),\n            'probability_exoplanet': float(proba[1]),\n            'probability_false_positive': float(proba[0]),\n            'top_features': [(f, float(i)) for f, i in top_features[:5]]\n        }\n    \n    def _classify_planet_type(self, obs: dict) -> dict:\n        \"\"\"Classify planet type based on radius and temperature.\"\"\"\n        radius = obs['koi_prad']\n        temp = obs['koi_teq']\n        \n        # Estimate mass (rough approximation)\n        if radius < 1.5:\n            mass = radius ** 3.7  # Rocky planets\n        elif radius < 4:\n            mass = radius ** 2.5  # Transition\n        else:\n            mass = radius ** 1.8  # Gas giants\n        \n        # Classify by size\n        if radius < 0.8:\n            category = \"Sub-Earth\"\n            planet_class = \"Small rocky planet\"\n        elif radius <= 1.25:\n            category = \"Earth-sized\"\n            planet_class = \"Terrestrial planet\"\n        elif radius <= 2.0:\n            category = \"Super-Earth\"\n            planet_class = \"Large rocky planet\"\n        elif radius <= 4.0:\n            category = \"Mini-Neptune\"\n            planet_class = \"Small gas planet\"\n        elif radius <= 8.0:\n            category = \"Neptune-sized\"\n            planet_class = \"Ice giant\"\n        else:\n            category = \"Jupiter-sized\"\n            planet_class = \"Gas giant\"\n        \n        # Temperature classification\n        if not np.isnan(temp):\n            if temp > 1500:\n                thermal_class = \"Ultra-hot\"\n            elif temp > 1000:\n                thermal_class = \"Hot\"\n            elif temp > 400:\n                thermal_class = \"Warm\"\n            elif temp >= 200:\n                thermal_class = \"Temperate\"\n            else:\n                thermal_class = \"Cold\"\n        else:\n            thermal_class = \"Unknown\"\n        \n        # Special classifications\n        if radius > 8 and not np.isnan(temp) and temp > 1000:\n            special_type = \"Hot Jupiter\"\n        elif radius < 1.5 and not np.isnan(temp) and 250 < temp < 350:\n            special_type = \"Potentially Earth-like\"\n        else:\n            special_type = None\n        \n        return {\n            \"category\": category,\n            \"class\": planet_class,\n            \"thermal_class\": thermal_class,\n            \"special_type\": special_type,\n            \"mass_estimate\": round(mass, 2),\n            \"size_comparison\": f\"{radius:.2f}x Earth radius, {radius/11.2:.3f}x Jupiter radius\"\n        }\n    \n    def _assess_habitability(self, obs: dict) -> dict:\n        \"\"\"Assess potential habitability.\"\"\"\n        radius = obs['koi_prad']\n        temp = obs['koi_teq']\n        insol = obs['koi_insol']\n        \n        favorable = []\n        unfavorable = []\n        score = 0\n        \n        # Size check\n        if 0.8 <= radius <= 1.7:\n            favorable.append(\"Radius in potentially habitable range (0.8-1.7 Earth radii)\")\n            score += 30\n        elif radius < 0.8:\n            unfavorable.append(\"Too small - may lack atmosphere retention\")\n        else:\n            unfavorable.append(\"Too large - likely gas giant, not rocky\")\n        \n        # Temperature check\n        if not np.isnan(temp):\n            if 250 <= temp <= 350:\n                favorable.append(\"Temperature in liquid water range (250-350K)\")\n                score += 40\n            elif 200 <= temp <= 400:\n                favorable.append(\"Temperature near habitable range\")\n                score += 20\n            elif temp > 400:\n                unfavorable.append(\"Too hot for liquid water\")\n            else:\n                unfavorable.append(\"Too cold for liquid water\")\n        \n        # Stellar flux check\n        if not np.isnan(insol):\n            if 0.25 <= insol <= 4:\n                favorable.append(\"Stellar flux supports liquid water\")\n                score += 20\n            elif insol > 4:\n                unfavorable.append(\"Receives too much stellar radiation\")\n            else:\n                unfavorable.append(\"Receives too little stellar radiation\")\n        \n        # Orbital period (proxy for distance)\n        if 200 <= obs['koi_period'] <= 500:\n            favorable.append(\"Orbital period suggests habitable zone orbit\")\n            score += 10\n        \n        is_habitable = score >= 50\n        \n        # Habitable zone position\n        if not np.isnan(insol):\n            if 0.9 <= insol <= 1.1:\n                hz_position = \"Center of habitable zone\"\n                hz_status = \"Optimal\"\n            elif 0.5 <= insol <= 2.0:\n                hz_position = \"Within habitable zone\"\n                hz_status = \"Favorable\"\n            elif insol < 0.5:\n                hz_position = \"Outside (too far)\"\n                hz_status = \"Too cold\"\n            else:\n                hz_position = \"Outside (too close)\"\n                hz_status = \"Too hot\"\n        else:\n            hz_position = \"Unknown\"\n            hz_status = \"Insufficient data\"\n        \n        # Temperature suitability\n        if not np.isnan(temp):\n            if 250 <= temp <= 350:\n                temp_suitability = \"Excellent - liquid water likely\"\n            elif 200 <= temp <= 400:\n                temp_suitability = \"Moderate - water possible under certain conditions\"\n            elif temp > 500:\n                temp_suitability = \"Poor - too hot\"\n            else:\n                temp_suitability = \"Poor - too cold\"\n        else:\n            temp_suitability = \"Unknown\"\n        \n        return {\n            \"is_habitable\": is_habitable,\n            \"score\": score,\n            \"favorable\": favorable,\n            \"unfavorable\": unfavorable,\n            \"hz_position\": hz_position,\n            \"hz_status\": hz_status,\n            \"temp_suitability\": temp_suitability\n        }\n    \n    def _assess_detection_quality(self, obs: dict) -> dict:\n        \"\"\"Assess quality of detection signal.\"\"\"\n        depth = obs['koi_depth']\n        duration = obs['koi_duration']\n        impact = obs['koi_impact']\n        \n        # Signal strength from transit depth\n        if depth > 5000:\n            signal_strength = \"Very strong\"\n            depth_quality = \"Excellent\"\n        elif depth > 1000:\n            signal_strength = \"Strong\"\n            depth_quality = \"Good\"\n        elif depth > 200:\n            signal_strength = \"Moderate\"\n            depth_quality = \"Fair\"\n        else:\n            signal_strength = \"Weak\"\n            depth_quality = \"Poor\"\n        \n        # Geometric probability (central transits are better)\n        if not np.isnan(impact):\n            if impact < 0.3:\n                geometric_prob = \"High (central transit)\"\n            elif impact < 0.7:\n                geometric_prob = \"Moderate\"\n            else:\n                geometric_prob = \"Low (grazing transit)\"\n        else:\n            geometric_prob = \"Unknown\"\n        \n        # Detection difficulty\n        if depth < 100:\n            difficulty = \"Very difficult - requires excellent data quality\"\n        elif depth < 500:\n            difficulty = \"Difficult - challenging to confirm\"\n        elif depth < 2000:\n            difficulty = \"Moderate - good candidate for confirmation\"\n        else:\n            difficulty = \"Easy - strong signal, high confidence\"\n        \n        # Overall quality\n        quality_score = 0\n        if depth > 500:\n            quality_score += 40\n        if not np.isnan(impact) and impact < 0.5:\n            quality_score += 30\n        if duration > 2:\n            quality_score += 30\n        \n        if quality_score >= 70:\n            overall = \"High quality detection\"\n        elif quality_score >= 40:\n            overall = \"Moderate quality detection\"\n        else:\n            overall = \"Low quality detection\"\n        \n        return {\n            \"overall_quality\": overall,\n            \"signal_strength\": signal_strength,\n            \"depth_quality\": depth_quality,\n            \"geometric_prob\": geometric_prob,\n            \"difficulty\": difficulty,\n            \"quality_score\": quality_score\n        }\n    \n    def _compare_to_known_planets(self, obs: dict) -> dict:\n        \"\"\"Compare to famous exoplanets.\"\"\"\n        comparisons = []\n        \n        radius = obs['koi_prad']\n        period = obs['koi_period']\n        temp = obs['koi_teq']\n        \n        # Earth comparison (always included)\n        comparisons.append({\n            \"planet\": \"Earth\",\n            \"similarity\": self._calculate_similarity(obs, {\n                'koi_prad': 1.0, 'koi_period': 365, 'koi_teq': 288\n            }),\n            \"notes\": \"Our home planet - 1.0 Earth radii, 365 day orbit, 288K\"\n        })\n        \n        # Kepler-186f (Earth-sized, habitable zone)\n        if 0.8 <= radius <= 1.5 and 100 <= period <= 200:\n            comparisons.append({\n                \"planet\": \"Kepler-186f\",\n                \"similarity\": self._calculate_similarity(obs, {\n                    'koi_prad': 1.1, 'koi_period': 130, 'koi_teq': 200\n                }),\n                \"notes\": \"First Earth-sized planet in habitable zone\"\n            })\n        \n        # Hot Jupiter comparison\n        if radius > 8 and not np.isnan(temp) and temp > 1000:\n            comparisons.append({\n                \"planet\": \"HD 209458 b (Osiris)\",\n                \"similarity\": self._calculate_similarity(obs, {\n                    'koi_prad': 14, 'koi_period': 3.5, 'koi_teq': 1500\n                }),\n                \"notes\": \"Prototypical Hot Jupiter\"\n            })\n        \n        # Super-Earth comparison\n        if 1.5 <= radius <= 2.5:\n            comparisons.append({\n                \"planet\": \"Kepler-22b\",\n                \"similarity\": self._calculate_similarity(obs, {\n                    'koi_prad': 2.4, 'koi_period': 290, 'koi_teq': 262\n                }),\n                \"notes\": \"Super-Earth in habitable zone\"\n            })\n        \n        return {\n            \"most_similar\": comparisons[0][\"planet\"] if comparisons else \"None\",\n            \"comparisons\": comparisons[:3]\n        }\n    \n    def _calculate_similarity(self, obs1: dict, obs2: dict) -> float:\n        \"\"\"Calculate similarity score between two observations.\"\"\"\n        score = 100\n        \n        if 'koi_prad' in obs2:\n            score -= abs(obs1['koi_prad'] - obs2['koi_prad']) * 10\n        if 'koi_period' in obs2:\n            score -= abs(obs1['koi_period'] - obs2['koi_period']) / 10\n        if 'koi_teq' in obs2 and not np.isnan(obs1['koi_teq']):\n            score -= abs(obs1['koi_teq'] - obs2['koi_teq']) / 20\n        \n        return max(0, min(100, score))\n    \n    def _detailed_feature_analysis(self, obs: dict, result: dict) -> dict:\n        \"\"\"Analyze each feature in detail.\"\"\"\n        contributions = {}\n        unusual = []\n        \n        for feature, importance in result['top_features']:\n            value = obs[feature]\n            contributions[feature] = {\n                \"value\": float(value) if not np.isnan(value) else None,\n                \"importance\": importance,\n                \"interpretation\": self._interpret_feature(feature, value)\n            }\n            \n            # Flag unusual values\n            if feature == 'koi_prad' and value > 20:\n                unusual.append(f\"Unusually large radius: {value:.1f} Earth radii\")\n            elif feature == 'koi_depth' and value > 50000:\n                unusual.append(f\"Extremely deep transit: {value:.0f} ppm\")\n            elif feature == 'koi_teq' and not np.isnan(value) and value > 3000:\n                unusual.append(f\"Extremely high temperature: {value:.0f} K\")\n        \n        return {\n            \"contributions\": contributions,\n            \"unusual_values\": unusual\n        }\n    \n    def _interpret_feature(self, feature: str, value: float) -> str:\n        \"\"\"Interpret what a feature value means.\"\"\"\n        if np.isnan(value):\n            return \"No data available\"\n        \n        interpretations = {\n            'koi_period': f\"{value:.1f} day orbit - \" + (\"very close\" if value < 10 else \"close\" if value < 100 else \"moderate distance\" if value < 300 else \"far\"),\n            'koi_depth': f\"{value:.0f} ppm - \" + (\"strong signal\" if value > 1000 else \"moderate signal\" if value > 200 else \"weak signal\"),\n            'koi_prad': f\"{value:.2f} Earth radii - \" + (\"Earth-sized\" if 0.8 <= value <= 1.25 else \"Super-Earth\" if value <= 2 else \"Gas giant\" if value > 8 else \"Neptune-sized\"),\n            'koi_teq': f\"{value:.0f} K - \" + (\"very hot\" if value > 1000 else \"warm\" if value > 400 else \"temperate\" if value > 250 else \"cold\"),\n            'koi_insol': f\"{value:.1f}x Earth flux - \" + (\"receives much more radiation\" if value > 4 else \"similar to Earth\" if 0.5 < value < 2 else \"receives less radiation\")\n        }\n        \n        return interpretations.get(feature, f\"Value: {value:.2f}\")\n    \n    def _estimate_semi_major_axis(self, obs: dict) -> float:\n        \"\"\"Estimate semi-major axis using Kepler's 3rd law (simplified).\"\"\"\n        period_years = obs['koi_period'] / 365.25\n        stellar_mass = self._estimate_stellar_mass(obs)\n        a_au = (period_years ** 2 * stellar_mass) ** (1/3)\n        return round(a_au, 3)\n    \n    def _estimate_stellar_mass(self, obs: dict) -> float:\n        \"\"\"Estimate stellar mass from radius (rough approximation).\"\"\"\n        if not np.isnan(obs['koi_srad']):\n            return obs['koi_srad'] ** 2.5\n        return 1.0\n    \n    def _classify_star(self, obs: dict) -> str:\n        \"\"\"Classify host star type.\"\"\"\n        temp = obs['koi_steff']\n        if np.isnan(temp):\n            return \"Unknown\"\n        \n        if temp > 7500:\n            return \"A-type (hot white star)\"\n        elif temp > 6000:\n            return \"F-type (white star)\"\n        elif temp > 5200:\n            return \"G-type (yellow star, Sun-like)\"\n        elif temp > 3700:\n            return \"K-type (orange star)\"\n        else:\n            return \"M-type (red dwarf)\"\n    \n    def _describe_orbital_distance(self, obs: dict) -> str:\n        \"\"\"Describe orbital distance in context.\"\"\"\n        period = obs['koi_period']\n        \n        if period < 1:\n            return \"Ultra-close orbit (< 1 day) - tidally locked, extreme conditions\"\n        elif period < 10:\n            return \"Very close orbit (hot planet, likely tidally locked)\"\n        elif period < 50:\n            return \"Close orbit (similar to Mercury)\"\n        elif period < 200:\n            return \"Inner system orbit (Venus to Earth distance)\"\n        elif period < 500:\n            return \"Middle system orbit (Earth to Mars distance)\"\n        else:\n            return \"Outer system orbit (beyond Mars)\"\n    \n    def _create_summary(self, obs, result, planet_type, habitability, quality) -> str:\n        \"\"\"Create human-readable summary.\"\"\"\n        pred = result['prediction']\n        conf = result['confidence']\n        \n        summary = f\"\"\"EXOPLANET CLASSIFICATION SUMMARY\n================================\n\nPREDICTION: {pred}\nConfidence: {conf:.1%}\nDetection Quality: {quality['overall_quality']}\n\nPHYSICAL CHARACTERISTICS:\nPlanet Type: {planet_type['category']} ({planet_type['class']})\nRadius: {obs['koi_prad']:.2f} Earth radii\nTemperature: {obs['koi_teq']:.0f} K ({obs['koi_teq']-273.15:.0f}Â°C)\nMass Estimate: {planet_type['mass_estimate']} Earth masses\n\nORBITAL CHARACTERISTICS:\nPeriod: {obs['koi_period']:.1f} days ({obs['koi_period']/365.25:.2f} years)\nDistance: ~{self._estimate_semi_major_axis(obs):.3f} AU\n{self._describe_orbital_distance(obs)}\n\nHABITABILITY ASSESSMENT:\nStatus: {'POTENTIALLY HABITABLE' if habitability['is_habitable'] else 'NOT HABITABLE'}\nScore: {habitability['score']}/100\nZone: {habitability['hz_position']}\nTemperature Suitability: {habitability['temp_suitability']}\n\nDETECTION QUALITY:\nSignal Strength: {quality['signal_strength']}\nTransit Depth: {obs['koi_depth']:.0f} ppm\nDifficulty: {quality['difficulty']}\n\nSTELLAR SYSTEM:\nStar Type: {self._classify_star(obs)}\nStellar Temp: {obs['koi_steff']:.0f} K\n\"\"\"\n        \n        if habitability['favorable']:\n            summary += f\"\\nFavorable Factors:\\n\"\n            for factor in habitability['favorable']:\n                summary += f\"  + {factor}\\n\"\n        \n        if habitability['unfavorable']:\n            summary += f\"\\nUnfavorable Factors:\\n\"\n            for factor in habitability['unfavorable']:\n                summary += f\"  - {factor}\\n\"\n        \n        return summary\n    \n    def _create_recommendations(self, result, planet_type, habitability, quality) -> str:\n        \"\"\"Generate scientific recommendations.\"\"\"\n        recs = \"FOLLOW-UP RECOMMENDATIONS\\n\" + \"=\"*50 + \"\\n\\n\"\n        \n        if result['prediction'] == 'CONFIRMED':\n            recs += \"This candidate shows strong exoplanet signatures.\\n\\n\"\n            \n            recs += \"RECOMMENDED NEXT STEPS:\\n\"\n            \n            if quality['quality_score'] >= 70:\n                recs += \"1. HIGH PRIORITY for follow-up observations\\n\"\n                recs += \"2. Radial velocity measurements to confirm mass\\n\"\n            else:\n                recs += \"1. Additional photometric observations to improve signal\\n\"\n                recs += \"2. Consider alternative detection methods\\n\"\n            \n            if habitability['is_habitable']:\n                recs += \"3. HABITABILITY PRIORITY - schedule for atmospheric characterization\\n\"\n                recs += \"4. Search for additional planets in system\\n\"\n                recs += \"5. Consider for JWST observation time\\n\"\n            \n            if planet_type['category'] in ['Super-Earth', 'Earth-sized']:\n                recs += f\"6. Excellent candidate for detailed study - {planet_type['category']} planets are scientifically valuable\\n\"\n            \n            recs += \"\\nSUGGESTED OBSERVATIONS:\\n\"\n            recs += \"- Spectroscopic follow-up for atmospheric composition\\n\"\n            recs += \"- Multi-wavelength photometry\\n\"\n            recs += \"- High-resolution imaging to rule out background stars\\n\"\n            \n        else:\n            recs += \"This appears to be a FALSE POSITIVE.\\n\\n\"\n            recs += \"LIKELY CAUSES:\\n\"\n            recs += \"- Eclipsing binary star system\\n\"\n            recs += \"- Background contaminating star\\n\"\n            recs += \"- Stellar variability or activity\\n\"\n            recs += \"- Instrumental artifact\\n\\n\"\n            recs += \"RECOMMENDED ACTION:\\n\"\n            recs += \"- Mark as low priority for follow-up\\n\"\n            recs += \"- May require adaptive optics imaging to resolve\\n\"\n        \n        recs += f\"\\nCONFIDENCE ASSESSMENT:\\n\"\n        recs += f\"Classification confidence: {result['confidence']:.1%}\\n\"\n        if result['confidence'] > 0.9:\n            recs += \"Very high confidence - trust this classification\\n\"\n        elif result['confidence'] > 0.75:\n            recs += \"Good confidence - reliable classification\\n\"\n        else:\n            recs += \"Moderate confidence - consider additional analysis\\n\"\n        \n        return recs","fileTypes":[],"file_path":"","password":false,"name":"code","advanced":true,"dynamic":true,"info":"","load_from_db":false,"title_case":false},"koi_depth":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":true,"placeholder":"","show":true,"name":"koi_depth","value":850,"display_name":"Transit Depth (ppm)","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_duration":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":true,"placeholder":"","show":true,"name":"koi_duration","value":2.8,"display_name":"Transit Duration (hours)","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_impact":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":false,"placeholder":"","show":true,"name":"koi_impact","value":0.35,"display_name":"Impact Parameter","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_insol":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":false,"placeholder":"","show":true,"name":"koi_insol","value":180,"display_name":"Stellar Flux","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_period":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":true,"placeholder":"","show":true,"name":"koi_period","value":9.5,"display_name":"Orbital Period (days)","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_prad":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":true,"placeholder":"","show":true,"name":"koi_prad","value":2.2,"display_name":"Planetary Radius (Earth radii)","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_slogg":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":false,"placeholder":"","show":true,"name":"koi_slogg","value":4.45,"display_name":"Stellar Gravity","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_srad":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":false,"placeholder":"","show":true,"name":"koi_srad","value":0.93,"display_name":"Stellar Radius","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_steff":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":false,"placeholder":"","show":true,"name":"koi_steff","value":5780,"display_name":"Stellar Temperature (K)","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"koi_teq":{"tool_mode":false,"trace_as_metadata":true,"list":false,"list_add_label":"Add More","required":false,"placeholder":"","show":true,"name":"koi_teq","value":1150,"display_name":"Temperature (K)","advanced":false,"dynamic":false,"info":"","title_case":false,"type":"float","_input_type":"FloatInput"},"model_path":{"tool_mode":false,"trace_as_input":true,"trace_as_metadata":true,"load_from_db":false,"list":false,"list_add_label":"Add More","required":false,"placeholder":"","show":true,"name":"model_path","value":"/app/data/.cache/langflow/b7c77ed2-b35a-4605-8b54-9a2787792e35/exoplanet_model.pkl","display_name":"Model File Path","advanced":true,"input_types":["Message"],"dynamic":false,"info":"","title_case":false,"type":"str","_input_type":"MessageTextInput"}},"description":"Classify stellar observations with detailed scientific analysis","icon":"ðŸŒŸ","base_classes":["tuple"],"display_name":"Exoplanet Classifier","documentation":"https://docs.langflow.org/components-custom-components","minimized":false,"custom_fields":{},"output_types":[],"pinned":false,"conditional_paths":[],"frozen":false,"outputs":[{"types":["tuple"],"selected":"tuple","name":"classification","hidden":null,"display_name":"Classification","method":"classify_observation","value":"__UNDEFINED__","cache":true,"required_inputs":null,"allows_loop":false,"options":null,"tool_mode":true},{"types":["tuple"],"selected":"tuple","name":"analysis","hidden":null,"display_name":"Detailed Analysis","method":"classify_observation","value":"__UNDEFINED__","cache":true,"required_inputs":null,"allows_loop":false,"options":null,"tool_mode":true},{"types":["tuple"],"selected":"tuple","name":"summary","hidden":null,"display_name":"Summary Message","method":"classify_observation","value":"__UNDEFINED__","cache":true,"required_inputs":null,"allows_loop":false,"options":null,"tool_mode":true},{"types":["tuple"],"selected":"tuple","name":"recommendations","hidden":null,"display_name":"Recommendations","method":"classify_observation","value":"__UNDEFINED__","cache":true,"required_inputs":null,"allows_loop":false,"options":null,"tool_mode":true}],"field_order":["koi_period","koi_depth","koi_duration","koi_prad","koi_teq","koi_insol","koi_impact","koi_steff","koi_srad","koi_slogg","model_path"],"beta":false,"legacy":false,"edited":true,"metadata":{},"tool_mode":false,"official":false},"showNode":true,"type":"ExoplanetClassifier","id":"CustomComponent-RHCL6"},"id":"CustomComponent-RHCL6","position":{"x":0,"y":0},"type":"genericNode"}],"viewport":{"x":1,"y":1,"zoom":1}},"description":"Classify stellar observations with detailed scientific analysis","name":"Exoplanet Classifier","id":"CustomComponent-RHCL6","is_component":true,"last_tested_version":"1.4.3"}